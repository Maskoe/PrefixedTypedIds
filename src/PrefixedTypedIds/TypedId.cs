using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using FastEndpoints;
using FastEndpoints.Swagger;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NJsonSchema;
using NJsonSchema.Generation;

namespace ManualAutoGeneratedIds;

public static class TypedIdExtensions
{
    /// <summary>
    /// This is to restore ef cores usual Update => AddOrUpdate behaviour based on the Id being the default.
    /// </summary>
    public static void CorrectEntityStates(this DbContext context)
    {
        var updatedEntries = context.ChangeTracker.Entries().Where(x => x.State == EntityState.Modified).ToList();
        foreach (var entry in updatedEntries)
        {
            if (entry.Entity.GetType().GetProperty(nameof(IHasTypedId<TypedId>.Id))?.GetValue(entry.Entity) is TypedId id &&
                !id.FromDb)
                entry.State = EntityState.Added;
        }
    }

    // FastEndpoints ModelBinding
    public static ParseResult IdParser<T>(object? input) where T : TypedId, new()
    {
        var str = input?.ToString();
        var id = new T { Value = str, FromDb = true };
        return new(true, id);
    }

    // Swagger Schema Convenience
    public static DocumentOptions AddTypedIdSchema(this DocumentOptions documentOptions)
    {
        documentOptions.DocumentSettings = d => d.SchemaSettings.SchemaProcessors.Add(new TypedIdSchemaProcessor());
        return documentOptions;
    }

    // Ef core Convenience
    public static void AddTypedId<TEntity, TId>(this EntityTypeBuilder<TEntity> entityTypeBuilder)
        where TEntity : class, IHasTypedId<TId>
        where TId : TypedId, new()
    {
        entityTypeBuilder
            .Property(x => x.Id)
            .HasConversion(x => x.Value, x => new TId { Value = x, FromDb = true });
    }

    // Ef core Convenience
    public static void RegisterAllTypedIds(this ModelBuilder modelBuilder)
    {
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            var entityClrType = entityType.ClrType;
            var interfaceType = entityClrType.GetInterfaces()
                .FirstOrDefault(i => i.IsGenericType &&
                                     i.GetGenericTypeDefinition() == typeof(IHasTypedId<>));

            if (interfaceType != null)
            {
                var typedIdType = interfaceType.GetGenericArguments()[0]; // This is TId
                var genericAddTypedIdMethod = typeof(TypedIdExtensions)
                    .GetMethod(nameof(TypedIdExtensions.AddTypedId), BindingFlags.Public | BindingFlags.Static)
                    .MakeGenericMethod(new Type[] { entityClrType, typedIdType });

                // Get the correctly typed EntityTypeBuilder
                var entityBuilderMethod = typeof(ModelBuilder)
                    .GetMethod(nameof(ModelBuilder.Entity), new Type[0])
                    .MakeGenericMethod(entityClrType);
                var entityBuilder = entityBuilderMethod.Invoke(modelBuilder, null);

                // Invoke the generic AddTypedId method with the correct EntityTypeBuilder
                genericAddTypedIdMethod.Invoke(null, new object[] { entityBuilder });
            }
        }
    }

    // FE Convenience
    public static void RegisterTypedIdSerializers(this Config fastEndpointConfig)
    {
        // Assuming `TypedId` and its subclasses are in the same assembly
        var typedId = typeof(TypedId);
        var assembly = Assembly.GetAssembly(typedId);

        // Get all non-abstract classes that inherit from TypedId
        var idTypes = assembly.GetTypes()
            .Where(t => t.IsClass && !t.IsAbstract && typedId.IsAssignableFrom(t));

        foreach (var idType in idTypes)
        {
            // Register each type with the appropriate JSON converter and parser
            var converterType = typeof(TypedIdJsonConverter<>).MakeGenericType(idType);
            dynamic converter = Activator.CreateInstance(converterType);

            var parserMethod = typeof(TypedIdExtensions).GetMethod(nameof(IdParser)).MakeGenericMethod(idType);
            Func<object?, ParseResult> parser = (input) => (ParseResult)parserMethod.Invoke(null, new object[] { input });

            fastEndpointConfig.Serializer.Options.Converters.Add(converter);
            fastEndpointConfig.Binding.ValueParserFor(idType, parser);
        }
    }
}

/// <summary>
/// Handles the generated SwaggerSchema for TypedIds
/// </summary>
public class TypedIdSchemaProcessor : ISchemaProcessor
{
    public void Process(SchemaProcessorContext context)
    {
        if (typeof(TypedId).IsAssignableFrom(context.ContextualType.Type))
        {
            context.Schema.Enumeration.Clear();
            context.Schema.Properties.Clear();
            context.Schema.Type = JsonObjectType.String;
        }
    }
}

/// <summary>
/// Handles the (De)Serialization of TypedIds for http requests and responses.
/// </summary>
public class TypedIdJsonConverter<TId> : JsonConverter<TId> where TId : TypedId, new()
{
    public override TId Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType is JsonTokenType.Null)
            return null;

        var value = JsonSerializer.Deserialize<string>(ref reader, options);
        var id = new TId { Value = value, FromDb = true };
        return id;
    }

    public override void Write(Utf8JsonWriter writer, TId value, JsonSerializerOptions options)
    {
        if (value is null)
            writer.WriteNullValue();
        else
            JsonSerializer.Serialize(writer, value.Value, options);
    }
}

/// <summary>
/// A TypedId requiring a prefix. The underlying id is a string with prefix + 6 randomly generated characters. "cc-hsi7g4".
/// </summary>
public abstract record TypedId
{
    private string val;

    public string Value
    {
        get => val;
        init
        {
            if (value.Split("-").FirstOrDefault() != prefix)
                throw new Exception($"Id {value} has the wrong prefix. Expected: {prefix}");
            val = value;
        }
    }

    public bool FromDb { get; init; }
    protected abstract string prefix { get; }

    protected TypedId()
    {
        val = prefix + "-" + GenerateRandomString(6);
    }

    public static string GenerateRandomString(int length, string allowedChars = "abcdefghijklmnopqrstuvwxyz0123456789")
    {
        var stringBuilder = new StringBuilder(length);
        for (int i = 0; i < length; i++)
            stringBuilder.Append(allowedChars[Random.Shared.Next(allowedChars.Length)]);

        return stringBuilder.ToString();
    }
}

public interface IHasTypedId<T> where T : TypedId
{
    public T Id { get; set; }
}