using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using FastEndpoints;
using FastEndpoints.Swagger;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;
using NJsonSchema;
using NJsonSchema.Generation;

namespace ManualAutoGeneratedIds;

public static class TypedIdExtensions
{
    // FastEndpoints ModelBinding
    public static ParseResult IdParser<T>(object? input) where T : TypedId, new()
    {
        var str = input?.ToString();
        var id = new T { Value = str };
        return new(true, id);
    }

    // Swagger Schema Convenience
    public static DocumentOptions AddTypedIdSchema(this DocumentOptions documentOptions)
    {
        documentOptions.DocumentSettings = d => d.SchemaSettings.SchemaProcessors.Add(new TypedIdSchemaProcessor());
        return documentOptions;
    }

    // Ef core Convenience
    public static void ApplyTypedIdConversions(this ModelConfigurationBuilder configurationBuilder)
    {
        var assembly = Assembly.GetExecutingAssembly();
        var typedIdTypes = assembly.GetTypes().Where(t => t.IsClass && !t.IsAbstract && t.IsSubclassOf(typeof(TypedId)));

        foreach (var type in typedIdTypes)
        {
            var converterType = typeof(TypedIdConverter<>).MakeGenericType(type);
            configurationBuilder
                .Properties(type)
                .HaveConversion(converterType);
        }
    }

    // Ef core Convenience
    public static void RegisterTypedIdValueGenerators(this ModelBuilder modelBuilder)
    {
        var entityTypes = modelBuilder.Model.GetEntityTypes();

        foreach (var entityType in entityTypes)
        {
            var idType = entityType.ClrType.GetProperty("Id")?.PropertyType;
            if (idType is not null && idType.IsClass && !idType.IsAbstract && idType.IsSubclassOf(typeof(TypedId)))
            {
                var converterType = typeof(TypedIdValueGenerator<>).MakeGenericType(idType);
                modelBuilder.Entity(entityType.ClrType)
                    .Property("Id")
                    .ValueGeneratedOnAdd()
                    .HasValueGenerator(converterType);
            }
        }
    }

    // FE Convenience
    public static void RegisterTypedIdSerializers(this Config fastEndpointConfig)
    {
        // Assuming `TypedId` and its subclasses are in the same assembly
        var typedId = typeof(TypedId);
        var assembly = Assembly.GetAssembly(typedId);

        // Get all non-abstract classes that inherit from TypedId
        var idTypes = assembly.GetTypes()
            .Where(t => t.IsClass && !t.IsAbstract && typedId.IsAssignableFrom(t));

        foreach (var idType in idTypes)
        {
            // Register each type with the appropriate JSON converter and parser
            var converterType = typeof(TypedIdJsonConverter<>).MakeGenericType(idType);
            dynamic converter = Activator.CreateInstance(converterType);

            var parserMethod = typeof(TypedIdExtensions).GetMethod(nameof(IdParser)).MakeGenericMethod(idType);
            Func<object?, ParseResult> parser = (input) => (ParseResult)parserMethod.Invoke(null, new object[] { input });

            fastEndpointConfig.Serializer.Options.Converters.Add(converter);
            fastEndpointConfig.Binding.ValueParserFor(idType, parser);
        }
    }
}

/// <summary>
/// EF: Handles converting from string representation on the Db to TypedId in c# and revers.
/// </summary>
public class TypedIdConverter<T> : ValueConverter<T, string> where T : TypedId, new()
{
    public TypedIdConverter() : base(v => v.Value, v => new T { Value = v })
    {
    }
}

/// <summary>
/// EF: Handles generating values for null ids in EF core when Adding to DbContext.
/// </summary>
public class TypedIdValueGenerator<TId> : ValueGenerator<TId> where TId : TypedId, new()
{
    public override TId Next(EntityEntry entry) => new TId();

    public override bool GeneratesTemporaryValues { get; }
}

/// <summary>
/// Handles the generated SwaggerSchema for TypedIds
/// </summary>
public class TypedIdSchemaProcessor : ISchemaProcessor
{
    public void Process(SchemaProcessorContext context)
    {
        if (typeof(TypedId).IsAssignableFrom(context.ContextualType.Type))
        {
            context.Schema.Enumeration.Clear();
            context.Schema.Properties.Clear();
            context.Schema.Type = JsonObjectType.String;
        }
    }
}

/// <summary>
/// Handles the (De)Serialization of TypedIds for http requests and responses.
/// </summary>
public class TypedIdJsonConverter<TId> : JsonConverter<TId> where TId : TypedId, new()
{
    public override TId Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType is JsonTokenType.Null)
            return null;

        var value = JsonSerializer.Deserialize<string>(ref reader, options);
        var id = new TId { Value = value };
        return id;
    }

    public override void Write(Utf8JsonWriter writer, TId value, JsonSerializerOptions options)
    {
        if (value is null)
            writer.WriteNullValue();
        else
            JsonSerializer.Serialize(writer, value.Value, options);
    }
}

/// <summary>
/// A TypedId requiring a prefix. The underlying id is a string with prefix + 6 randomly generated characters. "cc-hsi7g4".
/// </summary>
public abstract record TypedId
{
    private string val;

    public string Value
    {
        get => val;
        init
        {
            if (value.Split("-").FirstOrDefault() != prefix)
                throw new Exception($"Id {value} has the wrong prefix. Expected: {prefix}");
            val = value;
        }
    }

    protected abstract string prefix { get; }

    protected TypedId()
    {
        val = prefix + "-" + GenerateRandomString(6);
    }

    public static string GenerateRandomString(int length, string allowedChars = "abcdefghijklmnopqrstuvwxyz0123456789")
    {
        var stringBuilder = new StringBuilder(length);
        for (int i = 0; i < length; i++)
            stringBuilder.Append(allowedChars[Random.Shared.Next(allowedChars.Length)]);

        return stringBuilder.ToString();
    }
}